%% SPRiNT: Spectral Parameterization Resolved in Time (Time-resolved FOOOF)
%
% Implementation based on:
%   Wilson et al. (2022). Time-resolved parameterization of aperiodic and
%   periodic brain activity. eLife, 11, e77348.
%   https://doi.org/10.7554/eLife.77348
%
% SPRiNT applies FOOOF (Fitting Oscillations & One Over F) in a sliding
% window fashion across time to track how aperiodic and periodic spectral
% parameters evolve dynamically.
%
% FOOOF model: log(P(f)) = log(L(f)) + sum(G(f, peak_params))
%   Aperiodic: L(f) = b - log(f^chi)  [offset b, exponent chi]
%   Peaks:     G(f) = a * exp(-(f-cf)^2 / (2*bw^2))  [Gaussian in log-power]
%
% Author: Generated by Claude
% Date:   2025

clear; clc; close all;

%% =========================================================
%  SECTION 1: GENERATE SIMULATED TEST DATA
% =========================================================

fprintf('=== Generating simulated test data ===\n');

% Signal parameters
fs      = 250;          % Sampling rate (Hz)
T       = 60;           % Duration (seconds)
N       = T * fs;       % Number of samples
t       = (0:N-1) / fs; % Time vector

% We simulate time-varying aperiodic and periodic parameters:
%   - Aperiodic exponent transitions from 1.5 → 2.5 (ramp up at 20s, down at 40s)
%   - Alpha peak (10 Hz) present 15s–45s, fading in/out
%   - Beta peak (20 Hz) present 30s–60s

rng(42); % reproducibility

% --- Time-varying ground truth parameters ---
% Aperiodic offset (constant)
true_offset = 1.0;

% Aperiodic exponent: piece-wise linear
true_exp = ones(1, N) * 1.5;
ramp_up   = (t >= 20 & t < 35);
ramp_down = (t >= 35 & t <= 50);
high      = (t >= 35);
true_exp(ramp_up)   = 1.5 + (t(ramp_up)   - 20) / 15 * 1.0;
true_exp(ramp_down) = 2.5 - (t(ramp_down) - 35) / 15 * 1.0;
true_exp(t > 50)    = 1.5;

% Alpha amplitude envelope (Gaussian bump in time)
alpha_cf  = 10;   % Hz
alpha_bw  = 2;    % Hz bandwidth
alpha_env = zeros(1, N);
alpha_env(t >= 15 & t <= 45) = ...
    0.8 * exp(-((t(t>=15 & t<=45)-30).^2) / (2*8^2));

% Beta amplitude envelope
beta_cf  = 20;
beta_bw  = 3;
beta_env = zeros(1, N);
beta_env(t >= 30) = 0.5 * (1 - exp(-(t(t>=30)-30)/5));

% --- Generate signal in frequency domain per short segment ---
% We'll build the raw time series by summing components:
%   1. Colored noise with time-varying exponent (aperiodic)
%   2. Narrow-band oscillations (periodic)

% Aperiodic component via filtered white noise
%   We approximate by generating short-time segments
seg_len = fs; % 1-second generation segments (overlap handled in STFT later)
signal  = zeros(1, N);

for seg_start = 1 : seg_len : N
    seg_end = min(seg_start + seg_len - 1, N);
    seg_idx = seg_start:seg_end;
    L       = length(seg_idx);
    exp_val = mean(true_exp(seg_idx));

    % White noise -> colored by 1/f^(exp/2) shaping in freq domain
    wn    = randn(1, L);
    fft_w = fft(wn);
    freqs = (0:L-1) * fs / L;
    freqs(1) = 1e-6; % avoid DC division
    shape = freqs .^ (-exp_val / 2);
    shape(1) = 0; % zero DC
    colored = real(ifft(fft_w .* shape));

    % Scale to match desired offset (in log-power space)
    colored = colored / (std(colored) + 1e-9);
    colored = colored * 10^(true_offset / 2);

    signal(seg_idx) = colored;
end

% Add alpha oscillation
alpha_osc = alpha_env .* cos(2*pi*alpha_cf*t + randn()*2*pi);
signal    = signal + alpha_osc;

% Add beta oscillation
beta_osc = beta_env .* cos(2*pi*beta_cf*t + randn()*2*pi);
signal   = signal + beta_osc;

% Add small white noise floor
signal = signal + 0.05 * randn(1, N);

fprintf('  Signal: %.0f s at %.0f Hz (%d samples)\n', T, fs, N);
fprintf('  Alpha peak: 10 Hz, active 15–45 s\n');
fprintf('  Beta peak:  20 Hz, active 30–60 s\n');
fprintf('  Aperiodic exponent: 1.5–2.5 (time-varying)\n\n');


%% =========================================================
%  SECTION 2: SPRINT PARAMETERS
% =========================================================

sprint.win_len   = 1.5;       % Window length (seconds) % was 2
sprint.win_step  = 0.25;     % Step size between windows (seconds) % was 0.5
sprint.freq_range = [2 40]; % Frequency range for fitting (Hz)
sprint.min_peak_height = 0.15;  % Minimum peak height (log power)
sprint.peak_threshold  = 2.0;  % SD threshold above aperiodic for peak detection
sprint.max_n_peaks     = 7;    % Maximum number of peaks to fit
sprint.peak_width_limits = [1 6]; % [min max] peak width (Hz, BW = 2*sigma*sqrt(2))
sprint.aperiodic_mode  = 'fixed'; % 'fixed' (no knee) or 'knee'

% Derived
sprint.win_samps  = round(sprint.win_len  * fs);
sprint.step_samps = round(sprint.win_step * fs);

% Window centers
win_starts  = 1 : sprint.step_samps : (N - sprint.win_samps + 1);
win_centers = (win_starts + sprint.win_samps/2 - 1) / fs;
n_wins      = length(win_starts);

fprintf('=== SPRiNT Configuration ===\n');
fprintf('  Window: %.1f s, Step: %.1f s\n', sprint.win_len, sprint.win_step);
fprintf('  Freq range: %.0f–%.0f Hz\n', sprint.freq_range(1), sprint.freq_range(2));
fprintf('  Number of windows: %d\n\n', n_wins);


%% =========================================================
%  SECTION 3: COMPUTE SHORT-TIME POWER SPECTRA (STFT-based)
% =========================================================

fprintf('=== Computing short-time power spectra ===\n');

% Use Hann window + zero-padding for frequency resolution
nfft   = 2^nextpow2(sprint.win_samps * 4); % zero-pad 4x for resolution
hann_w = hann(sprint.win_samps)';

% Frequency vector
freqs_all = (0 : nfft/2) * fs / nfft;
freq_mask = freqs_all >= sprint.freq_range(1) & freqs_all <= sprint.freq_range(2);
freqs     = freqs_all(freq_mask);
n_freqs   = length(freqs);

% Pre-allocate spectrogram
psd_matrix = zeros(n_freqs, n_wins);

% for wi = 1:n_wins
%     idx = win_starts(wi) : win_starts(wi) + sprint.win_samps - 1;
%     seg = signal(idx) .* hann_w;
%     X   = fft(seg, nfft);
%     psd = (2 / (fs * sum(hann_w.^2))) * abs(X(1:nfft/2+1)).^2;
%     psd(2:end-1) = psd(2:end-1); % one-sided
%     psd_matrix(:, wi) = psd(freq_mask);
% end

% Use Welch's method within each window for smoother PSDs
for wi = 1:n_wins
    idx = win_starts(wi) : win_starts(wi) + sprint.win_samps - 1;
    seg = signal(idx);

    % Welch: 50% overlapping sub-windows within the sliding window
    sub_win_len = round(sprint.win_samps / 2);  % sub-window = half of main window
    [pxx, f_welch] = pwelch(seg, hann(sub_win_len), round(sub_win_len*0.5), nfft, fs);

    psd_matrix(:, wi) = pxx(freq_mask);
end

fprintf('  Frequency resolution: %.3f Hz\n', freqs(2)-freqs(1));
fprintf('  Spectrogram size: %d freqs x %d windows\n\n', n_freqs, n_wins);


%% =========================================================
%  SECTION 4: FIT FOOOF MODEL TO EACH TIME WINDOW
% =========================================================

fprintf('=== Fitting FOOOF model to each window ===\n');

% Pre-allocate results
results.time        = win_centers;
results.offset      = NaN(1, n_wins);
results.exponent    = NaN(1, n_wins);
results.r_squared   = NaN(1, n_wins);
results.error       = NaN(1, n_wins);
results.peaks       = cell(1, n_wins);  % each cell: [cf, amplitude, bw]

log_freqs = log10(freqs);

for wi = 1:n_wins
    psd      = psd_matrix(:, wi)';
    log_psd  = log10(psd);

    % --- Step 1: Fit aperiodic component (initial) ---
    % ap_params = fit_aperiodic(log_freqs, log_psd, sprint.aperiodic_mode);

    % Exclude canonical oscillatory bands from initial aperiodic fit
    excl = (freqs >= 7 & freqs <= 14) | (freqs >= 15 & freqs <= 30);
    incl = ~excl;
    ap_params = fit_aperiodic(log_freqs(incl), log_psd(incl), sprint.aperiodic_mode);

    % --- Step 2: Iteratively find and remove peaks ---
    peaks_found = zeros(0, 3); % [cf, amplitude, bw]
    log_psd_flat = log_psd - aperiodic_model(log_freqs, ap_params, sprint.aperiodic_mode);

    for pk = 1:sprint.max_n_peaks
        % Find highest point above threshold
        [max_val, max_idx] = max(log_psd_flat);

        if max_val < sprint.min_peak_height
            break;
        end

        % Check if above threshold relative to local noise
        % local_std = std(log_psd_flat);
        % if max_val < sprint.peak_threshold * local_std
        %     break;
        % end

        % Estimate initial peak params: [cf, amp, bw_sigma]
        cf_init = freqs(max_idx);
        amp_init = max_val;
        bw_init  = 2.0; % initial sigma guess (Hz)

        % Fit Gaussian to the peak
        try
            peak_p = fit_gaussian_peak(freqs, log_psd_flat, cf_init, amp_init, bw_init, sprint);
            if ~isempty(peak_p)
                peaks_found(end+1, :) = peak_p; %#ok<AGROW>
                % Subtract fitted peak from flattened spectrum
                log_psd_flat = log_psd_flat - gaussian_peak(freqs, peak_p);
            end
        catch
            % Skip bad fits
        end

        % Refit aperiodic with peaks removed
        log_psd_no_peaks = log_psd - sum(gaussian_peak_matrix(freqs, peaks_found), 1);
        ap_params = fit_aperiodic(log_freqs, log_psd_no_peaks, sprint.aperiodic_mode);
        log_psd_flat = log_psd - aperiodic_model(log_freqs, ap_params, sprint.aperiodic_mode) ...
                       - sum(gaussian_peak_matrix(freqs, peaks_found), 1);
    end

    % --- Step 3: Final refit of aperiodic with all peaks removed ---
    if ~isempty(peaks_found)
        log_psd_no_peaks = log_psd - sum(gaussian_peak_matrix(freqs, peaks_found), 1);
        ap_params = fit_aperiodic(log_freqs, log_psd_no_peaks, sprint.aperiodic_mode);
    end

    % --- Step 4: Compute goodness of fit ---
    log_psd_hat = aperiodic_model(log_freqs, ap_params, sprint.aperiodic_mode) ...
                  + sum(gaussian_peak_matrix(freqs, peaks_found), 1);
    ss_res = sum((log_psd - log_psd_hat).^2);
    ss_tot = sum((log_psd - mean(log_psd)).^2);
    r2     = 1 - ss_res / ss_tot;
    rmse   = sqrt(mean((log_psd - log_psd_hat).^2));

    % Store
    results.offset(wi)    = ap_params(1);
    results.exponent(wi)  = ap_params(end); % last param is exponent
    results.r_squared(wi) = r2;
    results.error(wi)     = rmse;
    results.peaks{wi}     = peaks_found;

    if mod(wi, 20) == 0
        fprintf('  Window %d / %d (t=%.1fs): exp=%.2f, R²=%.3f, %d peaks\n', ...
            wi, n_wins, win_centers(wi), ap_params(end), r2, size(peaks_found,1));
    end
end

fprintf('\n  Done. Mean R² = %.3f\n\n', nanmean(results.r_squared));


%% =========================================================
%  SECTION 5: POST-PROCESS PEAKS — BUILD PEAK TIME SERIES
% =========================================================

% Extract peak center frequencies and amplitudes over time
% Cluster peaks by frequency proximity to form "peak tracks"

all_peaks_t  = [];
all_peaks_cf = [];
all_peaks_amp = [];
all_peaks_bw  = [];

for wi = 1:n_wins
    pk = results.peaks{wi};
    if ~isempty(pk)
        for pi = 1:size(pk,1)
            all_peaks_t(end+1)   = win_centers(wi);    
            all_peaks_cf(end+1)  = pk(pi, 1);          
            all_peaks_amp(end+1) = pk(pi, 2);          
            all_peaks_bw(end+1)  = pk(pi, 3);          
        end
    end
end


%% =========================================================
%  SECTION 6: VISUALIZATION
% =========================================================

fprintf('=== Generating plots ===\n');

fig = figure('Name','SPRiNT Results','Position',[50 50 1400 900],'Color','w');

% ---- (a) Raw signal ----
ax1 = subplot(4,3,[1 2 3]);
plot(t, signal, 'Color', [0.3 0.3 0.3], 'LineWidth', 0.5);
xlabel('Time (s)'); ylabel('Amplitude');
title('Simulated EEG-like Signal');
xlim([0 T]);
grid on; box off;

% ---- (b) Spectrogram (log power) ----
ax2 = subplot(4,3,[4 5 6]);
imagesc(win_centers, freqs, log10(psd_matrix));
axis xy;
colormap(ax2, 'jet');
colorbar;
xlabel('Time (s)'); ylabel('Frequency (Hz)');
title('Short-time Power Spectral Density (log_{10})');
ylim(sprint.freq_range);
clim_vals = prctile(log10(psd_matrix(:)), [5 95]);
clim(clim_vals);

% ---- (c) Aperiodic exponent over time ----
ax3 = subplot(4,3,7);
% Ground truth exponent (downsampled to window centers)
true_exp_at_wins = interp1(t, true_exp, win_centers);
plot(win_centers, true_exp_at_wins, 'k--', 'LineWidth', 2, 'DisplayName', 'Ground truth');
hold on;
plot(results.time, results.exponent, 'r-o', 'LineWidth', 1.5, 'MarkerSize', 3, 'DisplayName', 'SPRiNT');
legend('Location','best'); grid on; box off;
xlabel('Time (s)'); ylabel('\chi (exponent)');
title('Aperiodic Exponent');
ylim([0.5 3.5]);

% ---- (d) Aperiodic offset over time ----
ax4 = subplot(4,3,8);
plot(results.time, results.offset, 'b-o', 'LineWidth', 1.5, 'MarkerSize', 3);
yline(true_offset, 'k--', 'LineWidth', 2);
xlabel('Time (s)'); ylabel('Offset (log power)');
title('Aperiodic Offset');
grid on; box off;

% ---- (e) R-squared over time ----
ax5 = subplot(4,3,9);
plot(results.time, results.r_squared, 'g-', 'LineWidth', 1.5);
xlabel('Time (s)'); ylabel('R²');
title('Goodness of Fit (R²)');
ylim([0 1]); grid on; box off;

% ---- (f) Peak scatter: CF vs Time ----
ax6 = subplot(4,3,[10 11 12]);
scatter(all_peaks_t, all_peaks_cf, 20, all_peaks_amp, 'filled', 'MarkerFaceAlpha', 0.7);
colormap(ax6, 'hot');
cb = colorbar; cb.Label.String = 'Amplitude (log power)';
xlabel('Time (s)'); ylabel('Peak CF (Hz)');
title('Detected Oscillatory Peaks Over Time');
ylim(sprint.freq_range);
xlim([0 T]);
% Overlay ground truth windows
hold on;
patch([15 45 45 15], [8 8 12 12], 'cyan', 'FaceAlpha', 0.15, 'EdgeColor','cyan', 'DisplayName','True alpha');
patch([30 60 60 30], [16 16 24 24], 'magenta', 'FaceAlpha', 0.15, 'EdgeColor','magenta', 'DisplayName','True beta');
legend('Detected peaks','True alpha window','True beta window','Location','northeast');
grid on; box off;

sgtitle('SPRiNT: Time-Resolved Spectral Parameterization', 'FontSize', 14, 'FontWeight', 'bold');

linkaxes([ax1 ax2 ax3 ax4 ax5 ax6], 'x');

fprintf('  Plot complete.\n\n');


%% =========================================================
%  SECTION 7: EXAMPLE — PLOT A FEW INDIVIDUAL WINDOW FITS
% =========================================================

example_wins = round(linspace(5, n_wins-5, 6));

fig2 = figure('Name','Example Window Fits','Position',[100 100 1200 700],'Color','w');

for ei = 1:length(example_wins)
    wi = example_wins(ei);
    psd      = psd_matrix(:, wi)';
    log_psd  = log10(psd);

    % Reconstruct fit
    ap_params = [results.offset(wi), results.exponent(wi)];
    ap_fit    = aperiodic_model(log_freqs, ap_params, sprint.aperiodic_mode);
    pk        = results.peaks{wi};
    if ~isempty(pk)
        full_fit = ap_fit + sum(gaussian_peak_matrix(freqs, pk), 1);
    else
        full_fit = ap_fit;
    end

    subplot(2, 3, ei);
    plot(freqs, log_psd, 'k', 'LineWidth', 1.2, 'DisplayName', 'Measured');
    hold on;
    plot(freqs, ap_fit,  'b--', 'LineWidth', 1.5, 'DisplayName', 'Aperiodic');
    plot(freqs, full_fit,'r-', 'LineWidth', 1.5, 'DisplayName', 'Full model');
    xlabel('Frequency (Hz)'); ylabel('log_{10} Power');
    title(sprintf('t = %.1f s | \\chi=%.2f | R²=%.2f', ...
        win_centers(wi), results.exponent(wi), results.r_squared(wi)));
    legend('Location','northeast','FontSize',7);
    grid on; box off;
    xlim(sprint.freq_range);
end
sgtitle('FOOOF Fits at Example Time Windows', 'FontSize', 13, 'FontWeight', 'bold');


%% =========================================================
%  SECTION 8: SUMMARY STATISTICS
% =========================================================

fprintf('=== Summary Statistics ===\n');
fprintf('  Mean aperiodic exponent: %.3f ± %.3f\n', ...
    nanmean(results.exponent), nanstd(results.exponent));
fprintf('  Mean aperiodic offset:   %.3f ± %.3f\n', ...
    nanmean(results.offset), nanstd(results.offset));
fprintf('  Mean R²:                 %.3f ± %.3f\n', ...
    nanmean(results.r_squared), nanstd(results.r_squared));
fprintf('  Total peaks detected:    %d\n', length(all_peaks_cf));
if ~isempty(all_peaks_cf)
    fprintf('  Mean peak CF:            %.2f ± %.2f Hz\n', ...
        mean(all_peaks_cf), std(all_peaks_cf));
end

% Correlation: estimated vs true exponent
% valid = ~isnan(results.exponent);
% [r, p] = corr(true_exp_at_wins(valid)', results.exponent(valid)');
% fprintf('\n  Correlation (true vs estimated exponent): r=%.3f, p=%.4f\n', r, p);


%% =========================================================
%  LOCAL FUNCTIONS
% =========================================================

function ap = aperiodic_model(log_freqs, params, mode)
% Evaluate aperiodic model in log-log space
% params = [offset, (knee,) exponent]
    if strcmp(mode, 'knee')
        offset = params(1); 
        knee = params(2); 
        exp_ = params(3);
        ap = offset - log10(knee + 10.^(log_freqs * exp_));
    else % fixed
        offset = params(1); 
        exp_ = params(2);
        ap = offset - exp_ * log_freqs;
    end
end

function params = fit_aperiodic(log_freqs, log_psd, mode)
% Fit aperiodic component using robust linear/nonlinear regression
    if strcmp(mode, 'knee')
        % Nonlinear fit
        f0 = [mean(log_psd) + 2, 0, 1.5];
        opts = optimset('Display','off','TolFun',1e-6,'TolX',1e-6,'MaxIter',500);
        try
            params = fminsearch(@(p) sum((log_psd - aperiodic_model(log_freqs,p,'knee')).^2), ...
                f0, opts);
            params(3) = max(params(3), 0); % exponent >= 0
        catch
            params = fit_aperiodic(log_freqs, log_psd, 'fixed');
            params = [params(1), 0, params(2)];
        end
    else
        % Linear regression in log-log space: log_psd = offset - exp*log_freqs
        X = [ones(length(log_freqs),1), -log_freqs(:)];
        b = X \ log_psd(:);
        params = [b(1), max(b(2), 0)];
    end
end

function g = gaussian_peak(freqs, peak_p)
% Evaluate a single Gaussian peak in log-power vs linear-freq space
% peak_p = [cf, amplitude, sigma_hz]
    if isempty(peak_p), g = zeros(size(freqs)); return; end
    cf = peak_p(1); amp = peak_p(2); sigma = peak_p(3);
    g  = amp * exp(-(freqs - cf).^2 / (2 * sigma^2));
end

function G = gaussian_peak_matrix(freqs, peaks_found)
% Evaluate multiple Gaussian peaks; returns n_peaks x n_freqs matrix
    if isempty(peaks_found)
        G = zeros(1, length(freqs));
        return;
    end
    G = zeros(size(peaks_found,1), length(freqs));
    for i = 1:size(peaks_found,1)
        G(i,:) = gaussian_peak(freqs, peaks_found(i,:));
    end
end

function peak_p = fit_gaussian_peak(freqs, log_psd_flat, cf_init, amp_init, bw_init, sprint)
% Fit a single Gaussian peak; returns [cf, amplitude, sigma] or []
    % Constrain cf within ±2*bw of initial estimate, and within freq_range
    cf_lb  = max(cf_init - 5, sprint.freq_range(1));
    cf_ub  = min(cf_init + 5, sprint.freq_range(2));
    bw_lb  = sprint.peak_width_limits(1) / (2*sqrt(2*log(2))); % FWHM->sigma
    bw_ub  = sprint.peak_width_limits(2) / (2*sqrt(2*log(2)));

    % Simple bounded optimization
    lb = [cf_lb, 0,    bw_lb];
    ub = [cf_ub, amp_init*3, bw_ub];
    p0 = [cf_init, amp_init, bw_init];
    p0 = min(max(p0, lb), ub);

    cost_fn = @(p) sum((log_psd_flat - gaussian_peak(freqs, p)).^2);
    opts = optimset('Display','off','TolFun',1e-8,'TolX',1e-8,'MaxIter',300);

    try
        % p_fit = fminsearchbnd(cost_fn, p0, lb, ub, opts);
        opts = optimoptions('fmincon','Display','off','TolFun',1e-8,'TolX',1e-8,'MaxIter',300);
        p_fit = fmincon(cost_fn, p0, [], [], [], [], lb, ub, [], opts);
        % Validate
        if p_fit(2) < sprint.min_peak_height
            peak_p = [];
        elseif p_fit(3) < bw_lb || p_fit(3) > bw_ub
            peak_p = [];
        else
            peak_p = p_fit;
        end
    catch
        peak_p = [];
    end
end
% 
% function x = fminsearchbnd(fun, x0, lb, ub, options)
% % Bounded fminsearch via transformation (simulated variable transformation)
% % Uses sigmoid-like mapping to enforce bounds
%     n = length(x0);
% 
%     % Transform x0 to unconstrained space
%     function u = to_u(x)
%         u = zeros(size(x));
%         for k = 1:n
%             if lb(k)==ub(k), u(k) = 0; continue; end
%             u(k) = log((x(k)-lb(k)) / (ub(k)-x(k)));
%         end
%     end
% 
%     function x = from_u(u)
%         x = zeros(size(u));
%         for k = 1:n
%             if lb(k)==ub(k), x(k) = lb(k); continue; end
%             x(k) = lb(k) + (ub(k)-lb(k)) / (1 + exp(-u(k)));
%         end
%     end
% 
%     u0 = to_u(x0);
%     fun_u = @(u) fun(from_u(u));
%     u_opt = fminsearch(fun_u, u0, options);
%     x = from_u(u_opt);
%     % Clamp to bounds
%     x = min(max(x, lb), ub);
% end
