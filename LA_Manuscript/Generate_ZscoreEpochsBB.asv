function [] = Generate_ZscoreEpochsBB()

% 1 ---------- LOOP THROUGH TABLE

% 2 ---------- FOR EACH ROW
%   i. ------- Get Hemisphere
%   ii. ------ Get Brain Area
%   iii. ----- Get Block ID
%   iv. ------ Find appropriate .mat file 

% 3 ---------- LOAD in BLOCK FILE

% 4 ---------- For each FOOOF
%   i -------- Collapse 5 second vectors into matrix for Block
%   ii ------- USE RESIDUAL

% 5 ---------- Z-score residual PSD for epoch

% 6 ---------- Re-extract z-scored power from Peaks

% 7 ---------- Add to table. 

PCname = getenv('COMPUTERNAME');
switch PCname
    case 'DLPFC'
        partCD = 'Z:\LossAversion\Patient folders\';

    case 'LATERALHABENULA'
        partCD = 'Y:\LossAversion\Patient folders\';

    case 'DESKTOP-I5CPDO7' % JAT WORK PC
        preBlockLOC = 'Z:\LossAversion\LH_Data\JAT_BlockData';
        preZscoreLOC = 'Z:\LossAversion\LH_Data\JAT_FoooFtables\';
        postZscoreLOC = 'Z:\LossAversion\LH_Data\JAT_FoooFtablesZS';
end % switch case

cd(preBlockLOC)
bDir1 = dir('*.mat');
bDir2 = struct2table(bDir1);
bDir3 = bDir2.name;

cd(preZscoreLOC)

mDir1 = dir('*.mat');
mDir2 = struct2table(mDir1);
mDir3 = mDir2.name;

% Loop through each block file
for mmi = 1:height(mDir2)           % -------------------- 1
    mainSubFile = mDir3{mmi}; 
    cd(preZscoreLOC)
    load(mainSubFile,'allFoooftab');

    for tti = 1:height(allFoooftab) % -------------------- 2

        tmpROW = allFoooftab(tti,:);

        subID = tmpROW.SubID{1};               % Get sub ID
        brainArea = tmpROW.brainA{1};          % Get Brain Area
        blockID = tmpROW.BlockID(1);           % Get Block ID

        % CD to Block 
        cd(preBlockLOC)

        % Create Search name
        searchName = [subID,'_',brainArea,'_','blocks.mat'];

        if matches(searchName,bDir3)
            load(searchName,'preBlockFooof')

            % Get appropriate block matrix for all 3 fooofs 
            % 1. Fooof
            tmpBlockFOF = preBlockFooof.FoooF.(['B_',num2str(blockID)]);

            tmpBlMatFOOOF = zeros(5,982);
            tmpBl_Exp_FOOOF = zeros(5,1);
            tmpBl_Off_FOOOF = zeros(5,1);
            for blmi = 1:5
                tmpBlMatFOOOF(blmi,:) = tmpBlockFOF{blmi}.power_spectrum - tmpBlockFOF{blmi}.ap_fit; 
                tmpBl_Exp_FOOOF(blmi,1) = tmpBlockFOF{blmi}.aperiodic_params(2);
                tmpBl_Off_FOOOF(blmi,1) = tmpBlockFOF{blmi}.aperiodic_params(1);
            end

            % 2. JATspecP FIXED
            tmpBlockSP_BOTH = preBlockFooof.JATSpecP.(['B_',num2str(blockID)]);

            tmpBlMatSP_FIXED = zeros(5,1001);
            tmpBl_Exp_FIXED = zeros(5,1);
            tmpBl_Off_FIXED = zeros(5,1);
            for blmi = 1:5
                tmpBlMatSP_FIXED(blmi,:) = tmpBlockSP_BOTH{blmi}.FIXED.residuals;
                tmpBl_Exp_FIXED(blmi,1) = tmpBlockSP_BOTH{blmi}.FIXED.params.exponent;
                tmpBl_Off_FIXED(blmi,1) = tmpBlockSP_BOTH{blmi}.FIXED.params.offset;
            end

            % 3. JATspecP KNEE
            tmpBlMatSP_KNEE = zeros(5,1001);
            tmpBl_Exp_KNEE = zeros(5,1);
            tmpBl_Off_KNEE = zeros(5,1);
            for blmi = 1:5
                tmpBlMatSP_KNEE(blmi,:) = tmpBlockSP_BOTH{blmi}.KNEE.residuals;
                tmpBl_Exp_KNEE(blmi,1) = tmpBlockSP_BOTH{blmi}.KNEE.params.exponent;
                tmpBl_Off_KNEE(blmi,1) = tmpBlockSP_BOTH{blmi}.KNEE.params.offset;
            end

            % Z-score residuals for each block
            % 1. FOOOF Voytek ---- Spectrum fit
            muIBI_Fooof = median(tmpBlMatFOOOF, 1, 'omitnan');
            sdIBI_Fooof = 1.4826 * mad(tmpBlMatFOOOF, 1, 1);
            sdIBI_Fooof(sdIBI_Fooof==0) = NaN;

            muIBI_Fooof = smoothdata(muIBI_Fooof, 'movmean', 7);
            sdIBI_Fooof = smoothdata(sdIBI_Fooof, 'movmean', 7);

            sdIBI_Fooof = max(sdIBI_Fooof, prctile(sdIBI_Fooof, 5));   % still floor it
            epoch_Fooof = tmpROW.FOOOFoutput{1}.power_spectrum - tmpROW.FOOOFoutput{1}.ap_fit; 
            zEpoch_Fooof = (epoch_Fooof - muIBI_Fooof) ./sdIBI_Fooof;

            freqs = tmpROW.FOOOFoutput{1}.freqs;
            peaks = tmpROW.FOOOFoutput{1}.peak_params;
            peaksN = [peaks , nan(height(peaks),1)];

            for ppi = 1:height(peaks)
                tmpHz = peaks(ppi,1);
                [~ , freqIND] = min(abs(freqs - tmpHz));
                zPkpwer = zEpoch_Fooof(freqIND);
                peaksN(ppi,4) = zPkpwer;
            end

            % 1. FOOOF Voytek ---- Fit parameters
            % Exponent
            muIBI_Exp_Fooof = median(tmpBl_Exp_FOOOF);
            sdIBI_Exp_Fooof = mad(tmpBl_Exp_FOOOF,1); % adds scaling to MAD

            epoch_Exp_Fooof = tmpROW.FOOOFoutput{1}.aperiodic_params(2);
            zEpoch_Exp_Fooof = (epoch_Exp_Fooof - muIBI_Exp_Fooof) ./sdIBI_Exp_Fooof;

            % Offset
            muIBI_Off_Fooof = median(tmpBl_Off_FOOOF);
            sdIBI_Off_Fooof = mad(tmpBl_Off_FOOOF,1); % adds scaling to MAD

            epoch_Off_Fooof = tmpROW.FOOOFoutput{1}.aperiodic_params(1);
            zEpoch_Off_Fooof = (epoch_Off_Fooof - muIBI_Off_Fooof) ./sdIBI_Off_Fooof;

            % Ouput table
            zEpoch_params_Fooof = table(zEpoch_Exp_Fooof,zEpoch_Off_Fooof,'VariableNames',{'Z_Exp','Z_Off'});

            % Store the z-scored power from Peaks into the output table
            allFoooftab.FOOOFoutput{tti}.zPkpwer = peaksN;
            allFoooftab.FOOOFoutput{tti}.zScoreEpoch = zEpoch_Fooof;
            allFoooftab.FOOOFoutput{tti}.BlkMed = muIBI_Fooof;
            allFoooftab.FOOOFoutput{tti}.BlkMad = sdIBI_Fooof;
            allFoooftab.FOOOFoutput{tti}.AfitParms = zEpoch_params_Fooof;

            % 2. JATspecP FIXED
            muIBI_spFIXED = median(tmpBlMatSPF, 1, 'omitnan');
            sdIBI_spFIXED = 1.4826 * mad(tmpBlMatSPF, 1, 1);
            sdIBI_spFIXED(sdIBI_spFIXED==0) = NaN;

            muIBI_spFIXED = smoothdata(muIBI_spFIXED, 'movmean', 9);
            sdIBI_spFIXED = smoothdata(sdIBI_spFIXED, 'movmean', 9);

            sdIBI_spFIXED = max(sdIBI_spFIXED, prctile(sdIBI_spFIXED, 5));   % still floor it
            epoch_spFIXED = transpose(tmpROW.SpecPARAMJ{1}.FIXED.residuals); 
            zEpoch_spFIXED = (epoch_spFIXED - muIBI_spFIXED) ./sdIBI_spFIXED;

            freqsF = tmpROW.SpecPARAMJ{1}.General.Freqs;
            peaksF = tmpROW.SpecPARAMJ{1}.FIXED.peaks.Summary;
            peaksNF = peaksF;
            peaksNF.AmpZS = nan(height(peaksNF),1);

            for ppi = 1:height(peaksNF)
                tmpHz = peaksNF.Hz(ppi);
                [~ , freqIND] = min(abs(freqsF - tmpHz));
                zPkpwer = zEpoch_spFIXED(freqIND);
                peaksNF.AmpZS(ppi) = zPkpwer;
            end

            % 2. JAT SpecP Fixed Fit parameters
            % Exponent
            muIBI_Exp_FIXED = median(tmpBl_Exp_FIXED);
            sdIBI_Exp_FIXED = mad(tmpBl_Exp_FIXED,1); % adds scaling to MAD

            epoch_Exp_FIXED = tmpROW.SpecPARAMJ{1}.FIXED.params.exponent;
            zEpoch_Exp_FIXED = (epoch_Exp_FIXED - muIBI_Exp_FIXED) ./sdIBI_Exp_FIXED;

            % Offset
            muIBI_Off_FIXED = median(tmpBl_Off_FIXED);
            sdIBI_Off_FIXED = mad(tmpBl_Off_FIXED,1); % adds scaling to MAD

            epoch_Off_FIXED = tmpROW.SpecPARAMJ{1}.FIXED.params.offset;
            zEpoch_Off_FIXED = (epoch_Off_FIXED - muIBI_Off_FIXED) ./sdIBI_Off_FIXED;

            % Ouput table
            zEpoch_params_FIXED = table(zEpoch_Exp_FIXED,zEpoch_Off_FIXED,'VariableNames',{'Z_Exp','Z_Off'});

            % Store the z-scored power from Peaks into the output table
            allFoooftab.SpecPARAMJ{tti}.FIXED.zPkpwer = peaksNF;
            allFoooftab.SpecPARAMJ{tti}.FIXED.zScoreEpoch = zEpoch_spFIXED;
            allFoooftab.SpecPARAMJ{tti}.FIXED.BlkMed = muIBI_spFIXED;
            allFoooftab.SpecPARAMJ{tti}.FIXED.BlkMad = sdIBI_spFIXED;
            allFoooftab.SpecPARAMJ{tti}.FIXED.AfitParms = zEpoch_params_FIXED;

            % 3. JATspecP KNEE
            muIBI_spKNEE = median(tmpBlMatSPK, 1, 'omitnan');
            sdIBI_spKNEE = 1.4826 * mad(tmpBlMatSPK, 1, 1);
            sdIBI_spKNEE(sdIBI_spKNEE==0) = NaN;

            muIBI_spKNEE = smoothdata(muIBI_spKNEE, 'movmean', 9);
            sdIBI_spKNEE = smoothdata(sdIBI_spKNEE, 'movmean', 9);

            sdIBI_spKNEE = max(sdIBI_spKNEE, prctile(sdIBI_spKNEE, 5));   % still floor it
            epoch_spKNEE = transpose(tmpROW.SpecPARAMJ{1}.KNEE.residuals);
            zEpoch_spKNEE = (epoch_spKNEE - muIBI_spKNEE) ./sdIBI_spKNEE;

            freqsK = tmpROW.SpecPARAMJ{1}.General.Freqs;
            peaksK = tmpROW.SpecPARAMJ{1}.KNEE.peaks.Summary;
            peaksNK = peaksK;
            peaksNK.AmpZS = nan(height(peaksNK),1);

            for ppi = 1:height(peaksNK)
                tmpHz = peaksNK.Hz(ppi);
                [~ , freqIND] = min(abs(freqsK - tmpHz));
                zPkpwer = zEpoch_spKNEE(freqIND);
                peaksNK.AmpZS(ppi) = zPkpwer;
            end

                        % 2. JAT SpecP Fixed Fit parameters
            % Exponent
            muIBI_Exp_FIXED = median(tmpBl_Exp_FIXED);
            sdIBI_Exp_FIXED = mad(tmpBl_Exp_FIXED,1); % adds scaling to MAD

            epoch_Exp_FIXED = tmpROW.SpecPARAMJ{1}.FIXED.params.exponent;
            zEpoch_Exp_FIXED = (epoch_Exp_FIXED - muIBI_Exp_FIXED) ./sdIBI_Exp_FIXED;

            % Offset
            muIBI_Off_FIXED = median(tmpBl_Off_FIXED);
            sdIBI_Off_FIXED = mad(tmpBl_Off_FIXED,1); % adds scaling to MAD

            epoch_Off_FIXED = tmpROW.SpecPARAMJ{1}.FIXED.params.offset;
            zEpoch_Off_FIXED = (epoch_Off_FIXED - muIBI_Off_FIXED) ./sdIBI_Off_FIXED;

            % Ouput table
            zEpoch_params_FIXED = table(zEpoch_Exp_FIXED,zEpoch_Off_FIXED,'VariableNames',{'Z_Exp','Z_Off'});

            % Store the z-scored power from Peaks into the output table
            allFoooftab.SpecPARAMJ{tti}.KNEE.zPkpwer = peaksNK;
            allFoooftab.SpecPARAMJ{tti}.KNEE.zScoreEpoch = zEpoch_spKNEE;
            allFoooftab.SpecPARAMJ{tti}.KNEE.BlkMed = muIBI_spKNEE;
            allFoooftab.SpecPARAMJ{tti}.KNEE.BlkMad = sdIBI_spKNEE;

            % Z_trial = (R_trial - muIBI) ./ sdIBI;
            % Z_trial = (R_trial - muIBI) ./ sdIBI;     % [nF x nT]
        else
            test = 1;

        end
    end % LOOP THROUGH ROWS
    cd(postZscoreLOC)
    namePARTS = split(mainSubFile,'.');
    saveNAME = [namePARTS{1},'_ZS.',namePARTS{2}];
    save(saveNAME,'allFoooftab');
    disp(saveNAME)
end % LOOP THROUGH SUBJECTS


% Inputs:
%   freqs   [nF x 1] frequency vector (3â€“55 Hz, same for baseline + trials)
%   R_ibi   [nF x nB] residual spectra for baseline (IBI 1s windows)
%   R_trial [nF x nT] residual spectra for trials (1s windows)
%
% Residual definition assumed:
%   R = log10(PSD) - log10(aperiodic_fit_knee)

% ===== #3: baseline mean & SD per frequency, then z-score trials =====
% muIBI  = mean(R_ibi,  2, 'omitnan');      % [nF x 1]
% sdIBI  = std (R_ibi,  0, 'omitnan');      % [nF x 1]
% sdIBI(sdIBI==0) = NaN;
% 
% muIBI = median(R_ibi, 2, 'omitnan');
% sdIBI = 1.4826 * mad(R_ibi, 1, 2);
% sdIBI(sdIBI==0) = NaN;

end